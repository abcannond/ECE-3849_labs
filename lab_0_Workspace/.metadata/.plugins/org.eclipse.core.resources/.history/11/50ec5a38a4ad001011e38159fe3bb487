/**
 * main_freertos.cpp — Multi-screen demo (Light + Joystick + Mic + Accel) on FreeRTOS
 * Hardware:
 *  - EK-TM4C1294XL LaunchPad
 *  - BoosterPack MKII (OPT3001, Joystick, Mic, Accelerometer)
 *  - LCD Crystalfontz128x128 (SPI0)
 *  - Buttons S1 (PA7), S2 (PA6)
 * Author: Edwin A. Rodríguez, 2025 — FreeRTOS port by ChatGPT
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

// ===================== TivaWare =====================
extern "C" {
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "driverlib/sysctl.h"
#include "driverlib/fpu.h"
#include "driverlib/gpio.h"
#include "driverlib/adc.h"
#include "driverlib/pin_map.h"
#include "driverlib/pwm.h"
#include "Crystalfontz128x128_ST7735.h"
#include "grlib/grlib.h"
#include "OPT3001.h"
}

// ===================== FreeRTOS =====================
extern "C" {
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
}

// ===================== Tus librerías =================
#include "button.h"
#include "joystick.h"

// ----------------------------------------------------
// Globals compartidos
// ----------------------------------------------------
tContext gContext;
uint32_t gSysClk = 120000000;

// Buttons / Joystick (igual que en tu código)
Button   btnLeft(S1, 2, 50, 25, ButtonPull::PullUp);
Button   btnRight(S2, 2, 50, 25, ButtonPull::PullUp);
Joystick js(JSX, JSY, JS1);

// Screen management
enum ScreenID { SCREEN_LUX = 0, SCREEN_JOYSTICK, SCREEN_MIC, SCREEN_ACCEL, SCREEN_SPECTRUM, SCREEN_COUNT };
volatile uint8_t currentScreen = SCREEN_LUX;

// Sensores (compartidos entre tareas)
volatile float gLuxValue  = 0.0f;
volatile float gMicLevel  = 0.0f;   // 0..1 (log-VU como antes)
volatile float gAx = 0, gAy = 0, gAz = 0;

// Mutex opcional si en algún momento dibuja más de una tarea (ahora solo UI dibuja)
SemaphoreHandle_t gUICtxMutex;

// ----------------------------------------------------
// Buzzer por PWM usando tarea + cola (no bloqueante)
// ----------------------------------------------------
typedef struct {
    uint32_t freq_hz;
    uint32_t duration_ms;
} BuzzerCmd;

static QueueHandle_t gBuzzerQ;

// Prototipos de funciones de periféricos/dibujo (Parte 2)
extern "C" void LCD_Init(void);
extern "C" void ADC_Init(void);
extern "C" uint16_t Mic_Read(void);
extern "C" void Accel_Read(float *x, float *y, float *z);
extern "C" float Mic_Level(void);
extern "C" void Buzzer_HWInit(void);
extern "C" void Buzzer_Start(uint32_t freq_hz);
extern "C" void Buzzer_Stop(void);
extern "C" void DrawHeader(const char *title, bool leftActive, bool rightActive);
extern "C" void Draw_Lux(float lux);
extern "C" void Draw_Joystick(float x, float y);
extern "C" void Draw_Mic(float level);
extern "C" void Particles_Init(void);
extern "C" void Draw_Accelerometer(float ax, float ay);

// ==== Spectrum Analyzer prototypes ====
void Spectrum_Init(void);
void Spectrum_ProcessFrame(void);
void Draw_Spectrum(const struct SpectrumTheme& theme);


#define FS_HZ_SPECT  8000
#define N_FRAME      256
#define N_BANDS      16

static const float kBandHz[N_BANDS] = {
    100, 150, 220, 320, 450, 630, 880, 1200,
    1700, 2300, 3100, 4200, 5500, 6800, 7800, 8500
};

struct Goertzel { float coeff, s1, s2; };
static Goertzel gz[N_BANDS];
static int16_t specBuf[N_FRAME];
static uint16_t specIdx = 0;

static float specView[N_BANDS];
static float specPeak[N_BANDS];
static float specPeakFall = 0.012f;

// DC blocker
static float hpf_y = 0.0f, hpf_prev = 0.0f;
static inline float dc_block(float x) {
    float y = (0.995f * hpf_y) + (x - hpf_prev);
    hpf_y = y; hpf_prev = x;
    return y;
}


// ---------------------------------------------------------------------------
// Themes (como en tu original)
// ---------------------------------------------------------------------------
struct SpectrumTheme {
    uint32_t bgColor;
    uint32_t barBaseColor;
    uint32_t peakColor;
    bool gradient;
    const char* title;
};

const SpectrumTheme THEME_NEON_BLUE = { ClrBlack, 0x00A0FF, 0x00FFFF, true,  "Spectrum" };

// ----------------------------------------------------
// Callbacks de botones (cambian pantalla y piden beep)
// ----------------------------------------------------
static inline void buzzer_post(uint32_t f, uint32_t ms)
{
    if (!gBuzzerQ) return;
    BuzzerCmd cmd{f, ms};
    (void)xQueueSend(gBuzzerQ, &cmd, 0); // no bloquear
}

void OnLeftClick()
{
    // Beep corto grave
    buzzer_post(200, 40);
    // Pantalla previa (con wrap)
    uint8_t s = currentScreen;
    currentScreen = (s > 0) ? (s - 1) : (SCREEN_COUNT - 1);
}

void OnRightClick()
{
    // Beep corto agudo
    buzzer_post(300, 40);
    // Pantalla siguiente (con wrap)
    currentScreen = (uint8_t)((currentScreen + 1) % SCREEN_COUNT);
}

// ============================================================================
// Timer1 interrupt setup for 8 kHz sampling
// ============================================================================

static TaskHandle_t xSpectrumTaskHandle = nullptr; // handle para notificación

extern "C" void Timer1AIntHandler(void)
{
    // Limpia la interrupción
    TimerIntClear(TIMER1_BASE, TIMER_TIMA_TIMEOUT);

    // Notifica a la tarea de Spectrum
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    vTaskNotifyGiveFromISR(xSpectrumTaskHandle, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

void Timer1A_Init(uint32_t sysclk)
{
    SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER1);
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_TIMER1));

    TimerConfigure(TIMER1_BASE, TIMER_CFG_PERIODIC);
    uint32_t period = sysclk / 8000;  // 8 kHz
    TimerLoadSet(TIMER1_BASE, TIMER_A, period - 1);

    TimerIntEnable(TIMER1_BASE, TIMER_TIMA_TIMEOUT);
    IntEnable(INT_TIMER1A);
    TimerEnable(TIMER1_BASE, TIMER_A);
}

// ----------------------------------------------------
// Tareas
// ----------------------------------------------------

// 1) Servicio de entradas (botones + joystick) — 10 ms
static void vInputServiceTask(void *arg)
{
    (void)arg;
    // Inicializa tus drivers de entrada
    btnLeft.begin();
    btnRight.begin();
    js.begin();
    js.calibrateCenter(32);

    // Asigna callbacks
    btnLeft.attachClick(&OnLeftClick);
    btnRight.attachClick(&OnRightClick);

    for (;;)
    {
        // Tick de tus librerías (fiel a tu requerimiento)
        btnLeft.tick();
        btnRight.tick();
        js.tick();

        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

// 2) Tarea de LUX (OPT3001) — 1000 ms
static void vLuxTask(void *arg)
{
    (void)arg;
    // OPT3001
    OPT3001_Init();

    for (;;)
    {
        float lx = OPT3001_ReadLux();
        gLuxValue = lx;  // write atomically (float assignment is atomic on Cortex-M)
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

// 3) Tarea de Mic — 50 ms (calcula nivel RMS log)
static void vMicTask(void *arg)
{
    (void)arg;
    for (;;)
    {
        gMicLevel = Mic_Level();
        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

// 4) Tarea de UI — 50 ms (única que dibuja)
static void vUITask(void *arg)
{
    (void)arg;

    // LCD + GFX
    LCD_Init();
    Particles_Init();

    for (;;)
    {
        uint8_t s = currentScreen;

        // Tomamos snapshot de datos compartidos
        float lux = gLuxValue;
        float mic = gMicLevel;

        switch (s)
        {
            case SCREEN_SPECTRUM:
                Draw_Spectrum(THEME_NEON_BLUE);
                break;
            case SCREEN_LUX:
                Draw_Lux(lux);
                break;

            case SCREEN_JOYSTICK:
                Draw_Joystick(js.x(), js.y());
                break;

            case SCREEN_MIC:
                Draw_Mic(mic);
                break;

            case SCREEN_ACCEL:
            default:
                Accel_Read((float*)&gAx, (float*)&gAy, (float*)&gAz);
                Draw_Accelerometer(gAx, gAy);
                break;
        }

        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

// 5) Tarea del Buzzer: toma comandos por cola y genera PWM el tiempo pedido
static void vBuzzerTask(void *arg)
{
    (void)arg;
    Buzzer_HWInit();

    BuzzerCmd cmd;
    for (;;)
    {
        if (xQueueReceive(gBuzzerQ, &cmd, portMAX_DELAY) == pdTRUE)
        {
            if (cmd.freq_hz > 0 && cmd.duration_ms > 0)
            {
                Buzzer_Start(cmd.freq_hz);
                vTaskDelay(pdMS_TO_TICKS(cmd.duration_ms));
                Buzzer_Stop();
            }
        }
    }
}

// ---------------------------------------------------------------------------
// Tarea Spectrum Analyzer — muestrea 8 kHz y procesa 30 FPS
// ---------------------------------------------------------------------------
// ============================================================================
// Spectrum Analyzer task — waits for Timer1 notification (8 kHz exact)
// ============================================================================
static void vSpectrumTask(void *arg)
{
    (void)arg;
    Spectrum_Init();  // inicializa Goertzel, buffers, etc.

    for (;;)
    {
        // Espera notificación del timer ISR
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

        // === Toma una muestra ===
        uint16_t raw = Mic_Read();
        float v = (float)raw / 4095.0f;
        float x = dc_block(v - 0.5f);
        specBuf[specIdx++] = (int16_t)(x * 32767.0f);

        // === Procesa un frame ===
        if (specIdx >= N_FRAME) {
            specIdx = 0;
            Spectrum_ProcessFrame();
        }
    }
}



// ----------------------------------------------------
// Hooks requeridos por FreeRTOS (evitan "unresolved symbol ...")
// ----------------------------------------------------
extern "C" void vApplicationIdleHook(void)
{
}

extern "C" void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName)
{
    (void)xTask;
    (void)pcTaskName;
    while (1) {}
}

// ============================================================================
// Spectrum Analyzer integration
// ============================================================================

void Spectrum_Init(void)
{
    for (int i = 0; i < N_BANDS; i++) {
        float omega = 2.0f * M_PI * kBandHz[i] / FS_HZ_SPECT;
        gz[i].coeff = 2.0f * cosf(omega);
        gz[i].s1 = gz[i].s2 = 0.0f;
        specView[i] = specPeak[i] = 0.0f;
    }
    specIdx = 0;
}

// ---------------------------------------------------------------------------
// Spectrum_ProcessFrame — Goertzel algorithm (igual que tu código base)
// ---------------------------------------------------------------------------
void Spectrum_ProcessFrame(void)
{
    int16_t local[N_FRAME];
    uint16_t idx = specIdx;
    for (int i = 0; i < N_FRAME; i++) {
        local[i] = specBuf[idx++]; if (idx >= N_FRAME) idx = 0;
    }
    for (int k = 0; k < N_BANDS; k++) gz[k].s1 = gz[k].s2 = 0.0f;

    for (int n = 0; n < N_FRAME; n++) {
        float w = 0.5f * (1.0f - cosf(2.0f * M_PI * n / (N_FRAME - 1)));
        float x = (local[n] / 32768.0f) * w;
        for (int k = 0; k < N_BANDS; k++) {
            float s = x + gz[k].coeff * gz[k].s1 - gz[k].s2;
            gz[k].s2 = gz[k].s1; gz[k].s1 = s;
        }
    }

    static float smooth[N_BANDS] = {0};
    for (int k = 0; k < N_BANDS; k++) {
        float s1 = gz[k].s1, s2 = gz[k].s2, c = gz[k].coeff;
        float power = s1*s1 + s2*s2 - c*s1*s2;
        if (power < 1e-12f) power = 1e-12f;

        float db = 10.0f * log10f(power);
        db = fminf(fmaxf(db, -60.0f), 0.0f);
        float norm = (db + 60.0f) / 60.0f;

        smooth[k] = 0.75f * smooth[k] + 0.25f * norm;
        specView[k] = smooth[k];
        if (specView[k] > specPeak[k]) specPeak[k] = specView[k];
        else specPeak[k] -= specPeakFall;
        if (specPeak[k] < 0) specPeak[k] = 0;
    }
}


// ---------------------------------------------------------------------------
// Draw_Spectrum() — igual que tu versión base
// ---------------------------------------------------------------------------
void Draw_Spectrum(const SpectrumTheme& theme)
{
    tRectangle bg = {0, 0, 127, 127};
    GrContextForegroundSet(&gContext, theme.bgColor);
    GrRectFill(&gContext, &bg);

    GrContextForegroundSet(&gContext, ClrWhite);
    GrStringDrawCentered(&gContext, theme.title, -1, 64, 8, false);

    const int barBottom = 120, barTop = 30;
    const int h = barBottom - barTop;
    const int screenWidth = 128;
    const int margin = 4;
    float availableWidth = screenWidth - 2 * margin;
    const float spacingRatio = 0.6f;
    float barWf = availableWidth / (N_BANDS + (N_BANDS - 1) * spacingRatio);
    int barW = (int)barWf;
    float gap = barWf * spacingRatio;
    float totalWidth = N_BANDS * barW + (N_BANDS - 1) * gap;
    float startX = (screenWidth - totalWidth) / 2.0f;

    for (int i = 0; i < N_BANDS; i++) {
        float lvl = fminf(fmaxf(specView[i], 0.0f), 1.0f);
        int filled = (int)(lvl * h);
        int yStart = barBottom - filled;
        int x = (int)(startX + i * (barW + gap));

        if (theme.gradient) {
            for (int y = barBottom; y > yStart; y--) {
                float frac = (float)(barBottom - y) / (float)h;
                uint8_t intensity = (uint8_t)(100 + 155 * powf(frac, 1.5f));
                uint32_t color = (intensity << 16) | (intensity << 8) | (theme.barBaseColor & 0xFF);
                GrContextForegroundSet(&gContext, color);
                GrLineDrawH(&gContext, x, x + barW, y);
            }
        } else {
            GrContextForegroundSet(&gContext, theme.barBaseColor);
            tRectangle barRect = {x, yStart, x + barW, barBottom};
            GrRectFill(&gContext, &barRect);
        }

        int peakY = barBottom - (int)(specPeak[i] * h);
        if (peakY < barTop) peakY = barTop;
        GrContextForegroundSet(&gContext, theme.peakColor);
        GrLineDrawH(&gContext, x, x + barW, peakY);
    }

    GrFlush(&gContext);
}



// ----------------------------------------------------
// main() — arranque del sistema + scheduler
// ----------------------------------------------------
int main(void)
{
    // FPU + reloj
    FPUEnable();
    FPULazyStackingEnable();

    gSysClk = SysCtlClockFreqSet((SYSCTL_XTAL_25MHZ | SYSCTL_OSC_MAIN |
                                  SYSCTL_USE_PLL | SYSCTL_CFG_VCO_240), 120000000);

    // ADC para mic+accel
    ADC_Init();

    // Mutex UI (por si luego hay más tareas que dibujan)
    gUICtxMutex = xSemaphoreCreateMutex();

    // Cola del buzzer
    gBuzzerQ = xQueueCreate(4, sizeof(BuzzerCmd));


    // Crea tareas (prioridades relativas)
    xTaskCreate(vInputServiceTask, "InputSvc", 512,  nullptr, tskIDLE_PRIORITY + 3, nullptr);
    xTaskCreate(vLuxTask,          "Lux",      512,  nullptr, tskIDLE_PRIORITY + 1, nullptr);
    xTaskCreate(vMicTask,          "Mic",      640,  nullptr, tskIDLE_PRIORITY + 2, nullptr);
    xTaskCreate(vUITask,           "UI",       768,  nullptr, tskIDLE_PRIORITY + 2, nullptr);
    xTaskCreate(vBuzzerTask,       "Buzzer",   512,  nullptr, tskIDLE_PRIORITY + 2, nullptr);
    // Crear la tarea del espectro
    xTaskCreate(vSpectrumTask, "Spectrum", 768, nullptr,
                tskIDLE_PRIORITY + 3, &xSpectrumTaskHandle);

    // Configurar Timer1 a 8 kHz
    Timer1A_Init(gSysClk);

    // Inicia el scheduler
    vTaskStartScheduler();

    // No debería regresar
    while (1) {}
}


// =================== Periféricos / Dibujo (Parte 2) ===================
extern "C" {
#include "driverlib/gpio.h"
#include "driverlib/adc.h"
#include "driverlib/ssi.h"
#include "driverlib/pwm.h"
#include "driverlib/rom_map.h"
#include "Crystalfontz128x128_ST7735.h"
#include "grlib/grlib.h"
}

extern tContext gContext;
extern uint32_t gSysClk;

// ---------------- ADC Mic/Accel como en tu código ----------------
#define MIC_ADC_BASE      ADC0_BASE
#define MIC_ADC_SEQ       3
#define MIC_ADC_CHANNEL   ADC_CTL_CH8  // PE5 -> AIN8

#define ACC_ADC_SEQ       2
#define ACC_CH_X          ADC_CTL_CH3  // PE0
#define ACC_CH_Y          ADC_CTL_CH2  // PE1
#define ACC_CH_Z          ADC_CTL_CH1  // PE2

void ADC_Init(void)
{
    SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_ADC0));

    GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_5);

    // Mic (SEQ3)
    ADCSequenceConfigure(ADC0_BASE, MIC_ADC_SEQ, ADC_TRIGGER_PROCESSOR, 0);
    ADCSequenceStepConfigure(ADC0_BASE, MIC_ADC_SEQ, 0, MIC_ADC_CHANNEL | ADC_CTL_IE | ADC_CTL_END);
    ADCSequenceEnable(ADC0_BASE, MIC_ADC_SEQ);
    ADCIntClear(ADC0_BASE, MIC_ADC_SEQ);

    // Accelerometer (SEQ2)
    ADCSequenceConfigure(ADC0_BASE, ACC_ADC_SEQ, ADC_TRIGGER_PROCESSOR, 0);
    ADCSequenceStepConfigure(ADC0_BASE, ACC_ADC_SEQ, 0, ACC_CH_X);
    ADCSequenceStepConfigure(ADC0_BASE, ACC_ADC_SEQ, 1, ACC_CH_Y);
    ADCSequenceStepConfigure(ADC0_BASE, ACC_ADC_SEQ, 2, ACC_CH_Z | ADC_CTL_IE | ADC_CTL_END);
    ADCSequenceEnable(ADC0_BASE, ACC_ADC_SEQ);
    ADCIntClear(ADC0_BASE, ACC_ADC_SEQ);
}

uint16_t Mic_Read(void)
{
    uint32_t value;
    ADCProcessorTrigger(MIC_ADC_BASE, MIC_ADC_SEQ);
    while (!ADCIntStatus(MIC_ADC_BASE, MIC_ADC_SEQ, false));
    ADCIntClear(MIC_ADC_BASE, MIC_ADC_SEQ);
    ADCSequenceDataGet(MIC_ADC_BASE, MIC_ADC_SEQ, &value);
    return (uint16_t)value;
}

void Accel_Read(float *x, float *y, float *z)
{
    uint32_t raw[3];
    ADCProcessorTrigger(ADC0_BASE, ACC_ADC_SEQ);
    while (!ADCIntStatus(ADC0_BASE, ACC_ADC_SEQ, false));
    ADCIntClear(ADC0_BASE, ACC_ADC_SEQ);
    ADCSequenceDataGet(ADC0_BASE, ACC_ADC_SEQ, raw);

    *x = ((float)raw[0] - 2048.0f) / 2048.0f;
    *y = ((float)raw[1] - 2048.0f) / 2048.0f;
    *z = ((float)raw[2] - 2048.0f) / 2048.0f;
}

// ------- Nivel de mic (idéntico) -------
float Mic_Level(void)
{
    const int N = 128;
    float sum = 0.0f;
    for (int i = 0; i < N; i++)
    {
        uint16_t s = Mic_Read();
        float v = (float)s / 4095.0f;
        float ac = v - 0.5f;
        sum += ac * ac;
    }
    float rms = sqrtf(sum / N);
    if (rms < 0.0001f) rms = 0.0001f;

    float db = 20.0f * log10f(rms / 0.25f);
    if (db < -60.0f) db = -60.0f;
    if (db > 0.0f) db = 0.0f;

    float level = (db + 60.0f) / 60.0f;
    return level;
}

// ---------------- LCD/GRLIB (idéntico) ----------------
void LCD_Init(void)
{
    SysCtlPeripheralEnable(SYSCTL_PERIPH_SSI0);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOM);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
    while (!SysCtlPeripheralReady(SYSCTL_PERIPH_SSI0));

    Crystalfontz128x128_Init();
    Crystalfontz128x128_SetOrientation(LCD_ORIENTATION_UP);
    GrContextInit(&gContext, &g_sCrystalfontz128x128);
    GrContextFontSet(&gContext, &g_sFontFixed6x8);
}

// ---------------- Header y pantallas (idéntico) ----------------
extern Button btnLeft;
extern Button btnRight;

void DrawHeader(const char *title, bool leftActive, bool rightActive)
{
    tRectangle header = {0, 0, 127, 20};
    GrContextForegroundSet(&gContext, ClrDarkBlue);
    GrRectFill(&gContext, &header);

    GrContextForegroundSet(&gContext, leftActive ? ClrYellow : ClrGray);
    GrStringDraw(&gContext, "<", -1, 4, 6, false);

    GrContextForegroundSet(&gContext, rightActive ? ClrYellow : ClrGray);
    GrStringDraw(&gContext, ">", -1, 118, 6, false);

    GrContextForegroundSet(&gContext, ClrWhite);
    GrStringDrawCentered(&gContext, title, -1, 64, 7, false);
}

void Draw_Lux(float lux)
{
    const float LUX_MAX = 1000.0f;
    int barWidth = (int)((lux / LUX_MAX) * 100);
    if (barWidth > 100) barWidth = 100;

    tRectangle bg = {0, 21, 127, 127};
    GrContextForegroundSet(&gContext, ClrBlack);
    GrRectFill(&gContext, &bg);
    DrawHeader("Ambient Light", btnLeft.isPressed(), btnRight.isPressed());

    char buf[32];
    snprintf(buf, sizeof(buf), "%.2f lx", lux);
    GrContextForegroundSet(&gContext, ClrYellow);
    GrStringDrawCentered(&gContext, buf, -1, 64, 50, false);

    tRectangle fill = {14, 80, 14 + barWidth, 95};
    GrContextForegroundSet(&gContext, ClrGreen);
    GrRectFill(&gContext, &fill);
    GrFlush(&gContext);
}

void Draw_Joystick(float x, float y)
{
    tRectangle bg = {0, 21, 127, 127};
    GrContextForegroundSet(&gContext, ClrBlack);
    GrRectFill(&gContext, &bg);
    DrawHeader("Joystick", btnLeft.isPressed(), btnRight.isPressed());

    int cx = 64, cy = 75, radius = 40;
    GrContextForegroundSet(&gContext, ClrWhite);
    GrCircleDraw(&gContext, cx, cy, radius);

    int px = cx + (int)(x * radius);
    int py = cy - (int)(y * radius);
    GrContextForegroundSet(&gContext, ClrCyan);
    GrCircleFill(&gContext, px, py, 3);

    char buf[32];
    snprintf(buf, sizeof(buf), "X=%.2f Y=%.2f", x, y);
    GrContextForegroundSet(&gContext, ClrYellow);
    GrStringDrawCentered(&gContext, buf, -1, 64, 115, false);

    GrFlush(&gContext);
}

void Draw_Mic(float level)
{
    tRectangle bg = {0, 21, 127, 127};
    GrContextForegroundSet(&gContext, ClrBlack);
    GrRectFill(&gContext, &bg);
    DrawHeader("Microphone", btnLeft.isPressed(), btnRight.isPressed());

    const int barX1 = 55, barX2 = 73, barY1 = 25, barY2 = 120;
    const int barHeight = barY2 - barY1;

    tRectangle outline = {barX1 - 2, barY1 - 2, barX2 + 2, barY2 + 2};
    GrContextForegroundSet(&gContext, ClrGray);
    GrRectDraw(&gContext, &outline);

    if (level < 0) level = 0; if (level > 1) level = 1;
    int filled = (int)(level * barHeight);
    int yStart = barY2 - filled;

    for (int y = barY2; y > yStart; y--)
    {
        float f = (float)(barY2 - y) / barHeight;
        uint32_t c = (f < 0.6f ? ClrGreen : f < 0.85f ? ClrYellow : ClrRed);
        GrContextForegroundSet(&gContext, c);
        GrLineDrawH(&gContext, barX1, barX2, y);
    }

    char buf[32];
    float dbVal = (level * 60.0f) - 60.0f;
    snprintf(buf, sizeof(buf), "%.1f dB", dbVal);
    GrContextForegroundSet(&gContext, ClrCyan);
    GrStringDrawCentered(&gContext, buf, -1, 64, 115, false);
    GrFlush(&gContext);
}

// ---------------- Partículas/Accel (idéntico) ----------------
#define NUM_PARTICLES 40
struct Particle { float x, y; float vx, vy; };
static Particle p[NUM_PARTICLES];

void Particles_Init(void)
{
    for (int i = 0; i < NUM_PARTICLES; i++) {
        p[i].x = rand() % 128;
        p[i].y = 30 + rand() % 90;
        p[i].vx = 0;
        p[i].vy = 0;
    }
}

void Draw_Accelerometer(float ax, float ay)
{
    tRectangle bg = {0, 21, 127, 127};
    GrContextForegroundSet(&gContext, ClrBlack);
    GrRectFill(&gContext, &bg);
    DrawHeader("Accelerometer", btnLeft.isPressed(), btnRight.isPressed());

    float gx = ax * 0.9f;
    float gy = -ay * 0.9f;

    for (int i = 0; i < NUM_PARTICLES; i++) {
        p[i].vx += gx;
        p[i].vy += gy;
        p[i].x  += p[i].vx;
        p[i].y  += p[i].vy;

        if (p[i].x < 0)   { p[i].x = 0;   p[i].vx *= -0.7f; }
        if (p[i].x > 127) { p[i].x = 127; p[i].vx *= -0.7f; }
        if (p[i].y < 25)  { p[i].y = 25;  p[i].vy *= -0.7f; }
        if (p[i].y > 125) { p[i].y = 125; p[i].vy *= -0.7f; }

        GrContextForegroundSet(&gContext, ClrCyan);
        GrCircleFill(&gContext, (int)p[i].x, (int)p[i].y, 2);
    }

    char buf[32];
    snprintf(buf, sizeof(buf), "AX=%.2f AY=%.2f", ax, ay);
    GrContextForegroundSet(&gContext, ClrYellow);
    GrStringDrawCentered(&gContext, buf, -1, 64, 115, false);
    GrFlush(&gContext);
}

// ---------------- Buzzer HW (no bloqueante) ----------------
// PF1 -> M0PWM1  (PWM0 Gen0 Out1)
#define BUZZER_PWM_BASE    PWM0_BASE
#define BUZZER_GEN         PWM_GEN_0
#define BUZZER_OUTNUM      PWM_OUT_1
#define BUZZER_OUTBIT      PWM_OUT_1_BIT

void Buzzer_HWInit(void)
{
    SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM0);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
    while (!SysCtlPeripheralReady(SYSCTL_PERIPH_PWM0));
    while (!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOF));

    GPIOPinConfigure(GPIO_PF1_M0PWM1);
    GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_1);

    // Reloj PWM = SysClk/64
    PWMClockSet(PWM0_BASE, PWM_SYSCLK_DIV_64);
}

void Buzzer_Start(uint32_t freq_hz)
{
    if (freq_hz == 0) { Buzzer_Stop(); return; }
    uint32_t pwmClock = gSysClk / 64;
    uint32_t period   = pwmClock / freq_hz;
    if (period < 4) period = 4;

    PWMGenConfigure(BUZZER_PWM_BASE, BUZZER_GEN, PWM_GEN_MODE_DOWN | PWM_GEN_MODE_NO_SYNC);
    PWMGenPeriodSet(BUZZER_PWM_BASE, BUZZER_GEN, period);
    PWMPulseWidthSet(BUZZER_PWM_BASE, BUZZER_OUTNUM, period / 2);

    PWMOutputState(BUZZER_PWM_BASE, BUZZER_OUTBIT, true);
    PWMGenEnable(BUZZER_PWM_BASE, BUZZER_GEN);
}

void Buzzer_Stop(void)
{
    PWMOutputState(BUZZER_PWM_BASE, BUZZER_OUTBIT, false);
}
