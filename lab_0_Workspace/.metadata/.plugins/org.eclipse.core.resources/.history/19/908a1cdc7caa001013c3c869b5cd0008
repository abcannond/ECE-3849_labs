/**
 * @file lv_port_disp_tm4c.c
 * @brief Display driver port for LVGL on EK-TM4C1294XL + Crystalfontz ST7735
 *
 * LVGL version: 9.x
 * Display: 128x128 ST7735 (Crystalfontz CFAG128x128)
 */

#include "lv_port_disp_tm4c.h"
#include "Crystalfontz128x128_ST7735.h"
#include "HAL_EK_TM4C1294XL_Crystalfontz128x128_ST7735.h"
#include "inc/hw_memmap.h"
#include "driverlib/ssi.h"
#include <stdint.h>
#include <stdbool.h>

/* -------------------------------------------------------------------------- */
/* Configuración básica                                                       */
/* -------------------------------------------------------------------------- */
#define LCD_HOR_RES 128
#define LCD_VER_RES 128
#define BUF_LINES   16      /* líneas por buffer parcial */

/* -------------------------------------------------------------------------- */
/* Prototipos internos                                                        */
/* -------------------------------------------------------------------------- */
static void disp_flush(lv_display_t *disp, const lv_area_t *area, uint8_t *px_map);
static void LCD_SetWindowRaw(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1);
static void lcd_send_pixels(const uint16_t *data, uint32_t count);
static void LCD_Clear(uint16_t color);

/* -------------------------------------------------------------------------- */
/* Buffers LVGL (2 buffers de 16 líneas cada uno)                             */
/* -------------------------------------------------------------------------- */
static lv_color_t buf_1[LCD_HOR_RES * BUF_LINES];
static lv_color_t buf_2[LCD_HOR_RES * BUF_LINES];

/* -------------------------------------------------------------------------- */
/* Inicialización del driver LVGL                                             */
/* -------------------------------------------------------------------------- */
void lv_port_disp_init(void)
{
    /* Inicializa hardware SPI + LCD */
    HAL_LCD_PortInit();
    HAL_LCD_SpiInit();
    Crystalfontz128x128_Init();
    Crystalfontz128x128_SetOrientation(LCD_ORIENTATION_UP);

    /* Limpieza inicial (pantalla negra) */
    LCD_Clear(0x0000);

    /* Crear display LVGL */
    lv_display_t *disp = lv_display_create(LCD_HOR_RES, LCD_VER_RES);
    lv_display_set_color_format(disp, LV_COLOR_FORMAT_RGB565);
    lv_display_set_flush_cb(disp, disp_flush);

    /* Buffers parciales (2 x 16 líneas) */
    lv_display_set_buffers(disp,
                           buf_1, buf_2,
                           sizeof(buf_1),
                           LV_DISPLAY_RENDER_MODE_PARTIAL);
}

/* -------------------------------------------------------------------------- */
/* Función de refresco (flush callback)                                       */
/* -------------------------------------------------------------------------- */
static void disp_flush(lv_display_t *disp, const lv_area_t *area, uint8_t *px_map)
{
    (void)disp;

    /* Clampeo de coordenadas */
    int32_t x1 = area->x1 < 0 ? 0 : area->x1;
    int32_t y1 = area->y1 < 0 ? 0 : area->y1;
    int32_t x2 = area->x2 >= LCD_HOR_RES ? LCD_HOR_RES - 1 : area->x2;
    int32_t y2 = area->y2 >= LCD_VER_RES ? LCD_VER_RES - 1 : area->y2;

    if (x2 < x1 || y2 < y1) {
        lv_display_flush_ready(disp);
        return;
    }

    uint32_t w = (uint32_t)(x2 - x1 + 1);
    uint32_t h = (uint32_t)(y2 - y1 + 1);

    /* Configurar ventana exacta (sin offsets) */
    LCD_SetWindowRaw(x1, y1, x2, y2);
    HAL_LCD_writeCommand(CM_RAMWR);

    const uint16_t *src = (const uint16_t *)px_map;
    for (uint32_t i = 0; i < w * h; i++) {
        uint16_t c = *src++;
        HAL_LCD_writeData(c >> 8);     /* MSB primero */
        HAL_LCD_writeData(c & 0xFF);   /* LSB después */
    }

    /* Espera a que finalice SPI */
    while (SSIBusy(LCD_SSI_BASE)) {}

    lv_display_flush_ready(disp);
}

/* -------------------------------------------------------------------------- */
/* Configura ventana RAW (sin offsets del driver original TI)                 */
/* -------------------------------------------------------------------------- */
static void LCD_SetWindowRaw(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1)
{
    HAL_LCD_writeCommand(CM_CASET);
    HAL_LCD_writeData(x0 >> 8);
    HAL_LCD_writeData(x0 & 0xFF);
    HAL_LCD_writeData(x1 >> 8);
    HAL_LCD_writeData(x1 & 0xFF);

    HAL_LCD_writeCommand(CM_RASET);
    HAL_LCD_writeData(y0 >> 8);
    HAL_LCD_writeData(y0 & 0xFF);
    HAL_LCD_writeData(y1 >> 8);
    HAL_LCD_writeData(y1 & 0xFF);
}

/* -------------------------------------------------------------------------- */
/* Envía un bloque de píxeles RGB565                                          */
/* -------------------------------------------------------------------------- */
static void lcd_send_pixels(const uint16_t *data, uint32_t count)
{
    while (count--) {
        uint16_t color = *data++;
        HAL_LCD_writeData(color >> 8);
        HAL_LCD_writeData(color & 0xFF);
    }
}

/* -------------------------------------------------------------------------- */
/* Limpieza completa del LCD                                                  */
/* -------------------------------------------------------------------------- */
static void LCD_Clear(uint16_t color)
{
    LCD_SetWindowRaw(0, 0, LCD_HOR_RES - 1, LCD_VER_RES - 1);
    HAL_LCD_writeCommand(CM_RAMWR);
    for (uint32_t i = 0; i < (LCD_HOR_RES * LCD_VER_RES); i++) {
        HAL_LCD_writeData(color >> 8);
        HAL_LCD_writeData(color & 0xFF);
    }
    while (SSIBusy(LCD_SSI_BASE)) {}
}
